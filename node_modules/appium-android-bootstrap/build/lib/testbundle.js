'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _Promise = require('babel-runtime/core-js/promise')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _child_process = require('child_process');

var _appiumUiautomator = require('appium-uiautomator');

var _net = require('net');

var _net2 = _interopRequireDefault(_net);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _appiumBaseDriver = require('appium-base-driver');

var _asyncbox = require('asyncbox');

var _appiumSupport = require('appium-support');

var log = _appiumSupport.logger.getLogger('AndroidTestBundle');

var COMMAND_TYPES = {
    ACTION: 'action',
    SHUTDOWN: 'shutdown'
};

var TestBundle = (function () {
    function TestBundle(adb, port) {
        _classCallCheck(this, TestBundle);

        this.adb = adb;
        this.webSocket = port; //opts.webSocket
        this.systemPort = port; //opts.systemPort
        log.debug('created testbundle');
        this.logcat_proc_for_testbundle = null;
        this.onUnexpectedShutdown = new _bluebird2['default'](function () {}).cancellable();
        this.ignoreUnexpectedShutdown = false;
        this.curCommand = {};
        this.shutdownUnexpected = false;
    }

    _createClass(TestBundle, [{
        key: 'init',
        value: function init() {
            return _regeneratorRuntime.async(function init$(context$2$0) {
                while (1) switch (context$2$0.prev = context$2$0.next) {
                    case 0:
                        this.uiAutomator2 = new _appiumUiautomator.UiAutomator_Test(this.adb);

                    case 1:
                    case 'end':
                        return context$2$0.stop();
                }
            }, null, this);
        }
    }, {
        key: 'start',
        value: function start() {
            return _regeneratorRuntime.async(function start$(context$2$0) {
                var _this = this;

                while (1) switch (context$2$0.prev = context$2$0.next) {
                    case 0:
                        context$2$0.next = 2;
                        return _regeneratorRuntime.awrap(this.init());

                    case 2:
                        context$2$0.prev = 2;
                        context$2$0.next = 5;
                        return _regeneratorRuntime.awrap(this.adb.removePortForward(this.systemPort));

                    case 5:
                        context$2$0.next = 9;
                        break;

                    case 7:
                        context$2$0.prev = 7;
                        context$2$0.t0 = context$2$0['catch'](2);

                    case 9:
                        context$2$0.next = 11;
                        return _regeneratorRuntime.awrap(this.adb.forwardPort(this.systemPort, 4724));

                    case 11:
                        context$2$0.next = 13;
                        return _regeneratorRuntime.awrap(this.uiAutomator2.start());

                    case 13:
                        this.process = context$2$0.sent;

                        this.process.on('output', function (stdout, stderr) {
                            var stdoutLines = (stdout || "").split("\n");
                            var uiautoLog = /\[APPIUM-UIAUTO\](.+)\[\/APPIUM-UIAUTO\]/;
                            var _iteratorNormalCompletion = true;
                            var _didIteratorError = false;
                            var _iteratorError = undefined;

                            try {
                                for (var _iterator = _getIterator(stdoutLines), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                    var line = _step.value;

                                    if (line.trim()) {
                                        if (uiautoLog.test(line)) {
                                            log.info('[TESTBUNDLE LOG] ' + uiautoLog.exec(line)[1].trim());
                                        } else {
                                            log.debug('[TESTBUNDLE STDOUT] ' + line);
                                        }
                                    }
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion && _iterator['return']) {
                                        _iterator['return']();
                                    }
                                } finally {
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }

                            var stderrLines = (stderr || "").split("\n");
                            var _iteratorNormalCompletion2 = true;
                            var _didIteratorError2 = false;
                            var _iteratorError2 = undefined;

                            try {
                                for (var _iterator2 = _getIterator(stderrLines), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                    var line = _step2.value;

                                    if (line.trim()) {
                                        log.debug('[TESTBUNDLE STDERR] ' + line);
                                    }
                                }
                            } catch (err) {
                                _didIteratorError2 = true;
                                _iteratorError2 = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                                        _iterator2['return']();
                                    }
                                } finally {
                                    if (_didIteratorError2) {
                                        throw _iteratorError2;
                                    }
                                }
                            }
                        });
                        this.uiAutomator2.on(_appiumUiautomator.UiAutomator_Test.EVENT_CHANGED, function callee$2$0(msg) {
                            return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                                while (1) switch (context$3$0.prev = context$3$0.next) {
                                    case 0:
                                        if (msg.state === _appiumUiautomator.UiAutomator_Test.STATE_STOPPED) {
                                            this.uiAutomator = null;
                                            log.debug("TestBundle shutdown unexpectedly");
                                            this.shutdownUnexpected = true;
                                            this.onUnexpectedShutdown.cancel(new Error("TestBundle shut down unexpectedly"));
                                        }

                                    case 1:
                                    case 'end':
                                        return context$3$0.stop();
                                }
                            }, null, _this);
                        });
                        context$2$0.next = 18;
                        return _regeneratorRuntime.awrap(new _Promise(function (resolve, reject) {
                            try {
                                _this.socketClient = _net2['default'].connect(_this.systemPort);
                                // Windows: the socket errors out when ADB restarts. Let's catch it to avoid crashing.
                                /*                this.socketClient.on('error', (err) => {
                                                    log.debug('//////////////')
                                                    log.debug(err)
                                                    log.debug('//////////////')
                                
                                
                                                    if (!this.ignoreUnexpectedShutdown) {
                                                        //throw new Error(`Android testbundle socket crashed: ${err}`);
                                                    }
                                                });*/
                                _this.socketClient.once('connect', function () {
                                    log.info("Android testbundle socket is now connected");
                                    resolve();
                                });
                            } catch (err) {
                                reject(err);
                            }
                        }));

                    case 18:
                        return context$2$0.abrupt('return', context$2$0.sent);

                    case 19:
                    case 'end':
                        return context$2$0.stop();
                }
            }, null, this, [[2, 7]]);
        }
    }, {
        key: 'exitHandler',

        // kill TestBundle
        /*        await this.adb.killProcessesByName('testbundle')
         let args = ['shell', 'am', 'instrument', '-w', '-e', 'class', 'com.boyaa.application.testbundle.TestBundle#test_RunServer',
         'com.boyaa.application.testbundle/android.test.InstrumentationTestRunner']
           log.debug("spawning: " + args.join(' '))
         this.proc = this.adb.createSubProcess(args)
           this.proc.on('exit', (code, signal) => {
         let msg = `Testbundle shutdown with code ${code}, ` + `signal ${signal}`;
         log.debug(msg);
         this.exitHandler.bind(this)
         })
         /!*        this.proc.on("error", function (err) {
         log.error("Unable to spawn adb: " + err.message);
         throw new Error("Unable to start Android Debug Bridge: " + err.message)
         }.bind(this))*!/
           await this.proc.start()
           this.proc.on('output', (stdout, stderr) => {
         log.debug(stdout)
         log.debug(stderr)
         })*/

        /*        log.debug('spawning xxxxxxxxxxxxx')
         log.debug(this.adb.getAdbPath() + this.adb.executable.defaultArgs.concat(args))
         this.proc = spawn(this.adb.getAdbPath(), this.adb.executable.defaultArgs.concat(args))
           this.proc.stdout.on('data', (data) => {
         log.debug(`stdout: ${data}`);
         });
         this.proc.stderr.on('data', (data) => {
         log.debug(`stderr: ${data}`);
         });*/

        /*        return await new Promise((resolve, reject) => {
         try {
         this.socketClient = net.connect(this.webSocket);
         // Windows: the socket errors out when ADB restarts. Let's catch it to avoid crashing.
         this.socketClient.on('error', (err) => {
         if (!this.ignoreUnexpectedShutdown) {
         //throw new Error(`Android bootstrap socket crashed: ${err}`);
         log.debug('//////////////////////////////////')
         log.debug(err)
         log.debug('//////////////////////////////////')
         throw new Error(`Android testbundle socket crashed: ${err}`)
         }
         });
         this.socketClient.once('connect', () => {
         log.info("Android testbundle socket is now connected");
         resolve();
         });
         } catch (err) {
         reject(err);
         }
         })*/
        value: function exitHandler() {
            if (this.socketClient) {
                log.debug('ending testbundle socketClient');
                this.socketClient.end();
                this.socketClient.destroy();
                this.socketClient = null;
            }
        }
    }, {
        key: 'startLogcat',
        value: function startLogcat() {
            log.debug("Starting logcat capture for testbundle");
            var logcat_args = ["logcat", "-v", "time", "-s", "BOYAA-TESTBUNDLE"];
            var executablePath = this.adb.executable.defaultArgs.join(' ');
            this.logcat_proc_for_testbundle = (0, _child_process.spawn)(executablePath, logcat_args);
            this.logcat_proc_for_testbundle.stdout.setEncoding('utf8');
            this.logcat_proc_for_testbundle.stderr.setEncoding('utf8');

            this.logcat_proc_for_testbundle.on('error', (function (err) {
                log.error('Logcat capture failed: ' + err.message);
                if (!this.calledBack) {
                    this.calledBack = true;
                    cb(err);
                }
            }).bind(this));
            this.logcat_proc_for_testbundle.on('exit', (function (code, signal) {
                log.debug('Logcat for testbundle terminated with code ' + code + ', signal ' + signal);
                this.logcat_proc_for_testbundle = null;
            }).bind(this));
            log.debug("Redirecting logcat logs into console to make it received by appium server");
        }
    }, {
        key: 'shutdown',
        value: function shutdown() {
            return _regeneratorRuntime.async(function shutdown$(context$2$0) {
                while (1) switch (context$2$0.prev = context$2$0.next) {
                    case 0:
                        log.debug('shutting down testbundle ...');

                        if (this.uiAutomator2) {
                            context$2$0.next = 4;
                            break;
                        }

                        log.warn("Cannot shut down Android testbundle; it has already shut down");
                        return context$2$0.abrupt('return');

                    case 4:
                        this.uiAutomator2.removeAllListeners(_appiumUiautomator.UiAutomator_Test.EVENT_CHANGED);

                        if (!this.socketClient) {
                            context$2$0.next = 9;
                            break;
                        }

                        if (this.shutdownUnexpected) {
                            context$2$0.next = 9;
                            break;
                        }

                        context$2$0.next = 9;
                        return _regeneratorRuntime.awrap(this.sendCommand(COMMAND_TYPES.SHUTDOWN));

                    case 9:
                        context$2$0.next = 11;
                        return _regeneratorRuntime.awrap(this.uiAutomator2.shutdown());

                    case 11:
                        this.uiAutomator2 = null;

                        context$2$0.next = 14;
                        return _regeneratorRuntime.awrap(this.adb.removePortForward(this.systemPort));

                    case 14:
                        log.debug('shutting down testbundle ...done!');

                    case 15:
                    case 'end':
                        return context$2$0.stop();
                }
            }, null, this);
        }
    }, {
        key: 'sendAction',
        value: function sendAction(action) {
            var params = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
            var extra;
            return _regeneratorRuntime.async(function sendAction$(context$2$0) {
                while (1) switch (context$2$0.prev = context$2$0.next) {
                    case 0:
                        extra = { action: action, params: params };
                        context$2$0.next = 3;
                        return _regeneratorRuntime.awrap(this.sendCommand(COMMAND_TYPES.ACTION, extra));

                    case 3:
                        return context$2$0.abrupt('return', context$2$0.sent);

                    case 4:
                    case 'end':
                        return context$2$0.stop();
                }
            }, null, this);
        }
    }, {
        key: 'sendCommand',
        value: function sendCommand(type) {
            var extra = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
            var execommand;
            return _regeneratorRuntime.async(function sendCommand$(context$2$0) {
                var _this3 = this;

                while (1) switch (context$2$0.prev = context$2$0.next) {
                    case 0:
                        if (this.socketClient) {
                            context$2$0.next = 2;
                            break;
                        }

                        throw new Error('Socket connection closed unexpectedly');

                    case 2:
                        execommand = function execommand() {
                            return _regeneratorRuntime.async(function execommand$(context$3$0) {
                                var _this2 = this;

                                while (1) switch (context$3$0.prev = context$3$0.next) {
                                    case 0:
                                        context$3$0.next = 2;
                                        return _regeneratorRuntime.awrap(new _Promise(function (resolve, reject) {
                                            var cmd = _Object$assign({ cmd: type }, extra);
                                            var cmdJson = JSON.stringify(cmd) + ' \n';
                                            log.debug('Sending command to testbundle: ' + _lodash2['default'].trunc(cmdJson, 1000).trim());
                                            try {
                                                _this2.socketClient.write(cmdJson);
                                                _this2.socketClient.setEncoding('utf8');
                                            } catch (err) {
                                                _this2.socketClient.removeAllListeners('data');
                                                _this2.socketClient.removeAllListeners('timeout');
                                                _this2.socketClient = _net2['default'].connect(_this2.systemPort, function () {
                                                    log.debug('socket reconnected!');
                                                    //return execommand()
                                                    resolve(execommand);
                                                });
                                            }
                                            var streamData = '';

                                            _this2.socketClient.setTimeout(1000 * 60, function () {
                                                log.debug('testbundle socket timeout');
                                                _this2.socketClient.removeAllListeners('data');
                                                _this2.socketClient.removeAllListeners('timeout');
                                                resolve('');
                                            });

                                            _this2.socketClient.on('data', function (data) {
                                                log.debug("Received command result from testbundle:");
                                                try {
                                                    streamData = JSON.parse(streamData + data);
                                                    log.debug(streamData);
                                                    // we successfully parsed JSON so we've got all the data,
                                                    // remove the socket listener and evaluate
                                                    _this2.socketClient.removeAllListeners('data');
                                                    _this2.socketClient.removeAllListeners('timeout');
                                                    if (streamData.status === 0) {
                                                        resolve(streamData.value);
                                                    }
                                                    reject((0, _appiumBaseDriver.errorFromCode)(streamData.status));
                                                } catch (ign) {
                                                    log.debug("Stream still not complete, waiting");
                                                    streamData += data;
                                                }
                                            });
                                        }));

                                    case 2:
                                        return context$3$0.abrupt('return', context$3$0.sent);

                                    case 3:
                                    case 'end':
                                        return context$3$0.stop();
                                }
                            }, null, _this3);
                        };

                        context$2$0.next = 5;
                        return _regeneratorRuntime.awrap(execommand());

                    case 5:
                        return context$2$0.abrupt('return', context$2$0.sent);

                    case 6:
                    case 'end':
                        return context$2$0.stop();
                }
            }, null, this);
        }
    }, {
        key: 'getConnection',
        value: function getConnection() {
            return _regeneratorRuntime.async(function getConnection$(context$2$0) {
                var _this4 = this;

                while (1) switch (context$2$0.prev = context$2$0.next) {
                    case 0:
                        return context$2$0.abrupt('return', new _bluebird2['default'](function (resolve, reject) {
                            _this4.socketClient = _net2['default'].connect(_this4.webSocket, function () {
                                log.debug('testbundle socket reconnected!!!');
                                resolve(this.socketClient);
                            });
                        }));

                    case 1:
                    case 'end':
                        return context$2$0.stop();
                }
            }, null, this);
        }

        /*async sendCommand(type, extra = {}) {
         /!*        if (!this.socketClient) {
         log.debug('==========socket closed========')
         throw new Error('Socket connection closed unexpectedly');
         }*!/
         return await new B((resolve, reject) => {
         let cmd = Object.assign({cmd: type}, extra);
         let cmdJson = `${JSON.stringify(cmd)}\n`;
         log.debug(`Sending command to android testbundle: ${_.trunc(cmdJson, 1000).trim()}`);
           let exeFunc = async () => {
         try {
           if (this.socketClient) {
         this.socketClient.write(cmdJson);
         this.socketClient.setEncoding('utf8');
         this.socketClient('data', (data) => {
         try {
         streamData = JSON.parse(streamData + data);
         // we successfully parsed JSON so we've got all the data,
         // remove the socket listener and evaluate
         this.socketClient.removeAllListeners('data');
         if (streamData.status === 0) {
         resolve(streamData.value);
         }
         log.debug("Received command result from testbundle:" + JSON.stringify(streamData));
         reject(errorFromCode(streamData.status));
         } catch (ign) {
         log.debug("Stream still not complete, waiting");
         streamData += data;
         }
         })
         }
           else {
         let client = new net.Socket();
         let streamData = '';
         client.connect(this.webSocket, '127.0.0.1', function() {
         log.debug('testbundle socket reconnected!')
         log.debug('send stream')
         client.write(cmdJson);
         log.debug('send end')
         client.setEncoding('utf8');
        
         })
         client.removeAllListeners('data');
         client.on('data', (data) => {
         try {
         log.debug("data:" + data.toString())
         streamData = JSON.parse(streamData + data);
           log.debug("streamdata: " + streamData)
           // we successfully parsed JSON so we've got all the data,
         // remove the socket listener and evaluate
         log.debug("Received command result from testbundle:" + JSON.stringify(streamData));
         if (streamData.status === 0) {
         resolve(streamData.value);
         client.removeAllListeners('data');
         client.close()
           }
           reject(errorFromCode(streamData.status));
         } catch (ign) {
         log.debug("Stream still not complete, waiting");
         streamData += data;
         }
         })
         }
             /!*                    this.socketClient.write(cmdJson);
         this.socketClient.setEncoding('utf8');
         let streamData = '';
         this.socketClient.on('data', (data) => {
         try {
         streamData = JSON.parse(streamData + data);
         // we successfully parsed JSON so we've got all the data,
         // remove the socket listener and evaluate
         this.socketClient.removeAllListeners('data');
         if (streamData.status === 0) {
         resolve(streamData.value);
         }
         log.debug("Received command result from testbundle:" + JSON.stringify(streamData));
         reject(errorFromCode(streamData.status));
         } catch (ign) {
         log.debug("Stream still not complete, waiting");
         streamData += data;
         }
         })*!/
           } catch (e) {
         throw new Error('Error sending command to testbundle' + e)
         }
         }
         //retry(2, exeFunc);
         exeFunc()
           /!*this.socketClient.write(cmdJson);
         this.socketClient.setEncoding('utf8');
         let streamData = '';
         this.socketClient.on('data', (data) => {
         try {
         streamData = JSON.parse(streamData + data);
         // we successfully parsed JSON so we've got all the data,
         // remove the socket listener and evaluate
         this.socketClient.removeAllListeners('data');
         if (streamData.status === 0) {
         resolve(streamData.value);
         }
         log.debug("Received command result from testbundle:" + JSON.stringify(streamData));
         reject(errorFromCode(streamData.status));
         } catch (ign) {
         log.debug("Stream still not complete, waiting");
         streamData += data;
         }
         })*!/
           })
           }*/
    }]);

    return TestBundle;
})();

exports['default'] = TestBundle;
module.exports = exports['default'];

// log.debug(err)
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi90ZXN0YnVuZGxlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZCQUFvQixlQUFlOztpQ0FHSixvQkFBb0I7O21CQUVuQyxLQUFLOzs7O3NCQUNQLFFBQVE7Ozs7d0JBQ1IsVUFBVTs7OztnQ0FDSSxvQkFBb0I7O3dCQUNKLFVBQVU7OzZCQUMvQixnQkFBZ0I7O0FBR3ZDLElBQU0sR0FBRyxHQUFHLHNCQUFPLFNBQVMsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDOztBQUVsRCxJQUFNLGFBQWEsR0FBRztBQUNsQixVQUFNLEVBQUUsUUFBUTtBQUNoQixZQUFRLEVBQUUsVUFBVTtDQUN2QixDQUFDOztJQUVJLFVBQVU7QUFDRCxhQURULFVBQVUsQ0FDQSxHQUFHLEVBQUUsSUFBSSxFQUFFOzhCQURyQixVQUFVOztBQUVSLFlBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFBO0FBQ2QsWUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUE7QUFDckIsWUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUE7QUFDdEIsV0FBRyxDQUFDLEtBQUssQ0FBQyxvQkFBb0IsQ0FBQyxDQUFBO0FBQy9CLFlBQUksQ0FBQywwQkFBMEIsR0FBRyxJQUFJLENBQUE7QUFDdEMsWUFBSSxDQUFDLG9CQUFvQixHQUFHLDBCQUFNLFlBQU0sRUFBRSxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUM7QUFDMUQsWUFBSSxDQUFDLHdCQUF3QixHQUFHLEtBQUssQ0FBQztBQUN0QyxZQUFJLENBQUMsVUFBVSxHQUFHLEVBQUUsQ0FBQTtBQUNwQixZQUFJLENBQUMsa0JBQWtCLEdBQUcsS0FBSyxDQUFBO0tBQ2xDOztpQkFYQyxVQUFVOztlQVlEOzs7O0FBQ1AsNEJBQUksQ0FBQyxZQUFZLEdBQUcsd0NBQXFCLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQzs7Ozs7OztTQUN0RDs7O2VBQ1U7Ozs7Ozs7eURBRUQsSUFBSSxDQUFDLElBQUksRUFBRTs7Ozs7eURBRVAsSUFBSSxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDOzs7Ozs7Ozs7Ozs7eURBSy9DLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDOzs7O3lEQUU1QixJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssRUFBRTs7O0FBQTlDLDRCQUFJLENBQUMsT0FBTzs7QUFFWiw0QkFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsUUFBUSxFQUFFLFVBQUMsTUFBTSxFQUFFLE1BQU0sRUFBSztBQUMxQyxnQ0FBSSxXQUFXLEdBQUcsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFBLENBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQzdDLGdDQUFNLFNBQVMsR0FBRywwQ0FBMEMsQ0FBQzs7Ozs7O0FBQzdELGtFQUFpQixXQUFXLDRHQUFFO3dDQUFyQixJQUFJOztBQUNULHdDQUFJLElBQUksQ0FBQyxJQUFJLEVBQUUsRUFBRTtBQUNiLDRDQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUU7QUFDdEIsK0NBQUcsQ0FBQyxJQUFJLHVCQUFxQixTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFHLENBQUM7eUNBQ2xFLE1BQU07QUFDSCwrQ0FBRyxDQUFDLEtBQUssMEJBQXdCLElBQUksQ0FBRyxDQUFDO3lDQUM1QztxQ0FDSjtpQ0FDSjs7Ozs7Ozs7Ozs7Ozs7OztBQUNELGdDQUFJLFdBQVcsR0FBRyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUEsQ0FBRSxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7Ozs7OztBQUM3QyxtRUFBaUIsV0FBVyxpSEFBRTt3Q0FBckIsSUFBSTs7QUFDVCx3Q0FBSSxJQUFJLENBQUMsSUFBSSxFQUFFLEVBQUU7QUFDYiwyQ0FBRyxDQUFDLEtBQUssMEJBQXdCLElBQUksQ0FBRyxDQUFDO3FDQUM1QztpQ0FDSjs7Ozs7Ozs7Ozs7Ozs7O3lCQUNKLENBQUMsQ0FBQztBQUNILDRCQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxvQ0FBaUIsYUFBYSxFQUFFLG9CQUFPLEdBQUc7Ozs7QUFDM0QsNENBQUksR0FBRyxDQUFDLEtBQUssS0FBSyxvQ0FBaUIsYUFBYSxFQUFFO0FBQzlDLGdEQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQztBQUN4QiwrQ0FBRyxDQUFDLEtBQUssQ0FBQyxrQ0FBa0MsQ0FBQyxDQUFBO0FBQzdDLGdEQUFJLENBQUMsa0JBQWtCLEdBQUcsSUFBSSxDQUFBO0FBQzlCLGdEQUFJLENBQUMsb0JBQW9CLENBQUMsTUFBTSxDQUFDLElBQUksS0FBSyxDQUFDLG1DQUFtQyxDQUFDLENBQUMsQ0FBQzt5Q0FDcEY7Ozs7Ozs7eUJBQ0osQ0FBQyxDQUFDOzt5REFDVSxhQUFhLFVBQUMsT0FBTyxFQUFFLE1BQU0sRUFBSztBQUMzQyxnQ0FBSTtBQUNBLHNDQUFLLFlBQVksR0FBRyxpQkFBSSxPQUFPLENBQUMsTUFBSyxVQUFVLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7O0FBWWpELHNDQUFLLFlBQVksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLFlBQU07QUFDcEMsdUNBQUcsQ0FBQyxJQUFJLENBQUMsNENBQTRDLENBQUMsQ0FBQztBQUN2RCwyQ0FBTyxFQUFFLENBQUM7aUNBQ2IsQ0FBQyxDQUFDOzZCQUNOLENBQUMsT0FBTyxHQUFHLEVBQUU7QUFDVixzQ0FBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDOzZCQUNmO3lCQUNKLENBQUM7Ozs7Ozs7Ozs7U0E0REw7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2VBRVUsdUJBQUc7QUFDVixnQkFBSSxJQUFJLENBQUMsWUFBWSxFQUFFO0FBQ25CLG1CQUFHLENBQUMsS0FBSyxDQUFDLGdDQUFnQyxDQUFDLENBQUE7QUFDM0Msb0JBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxFQUFFLENBQUE7QUFDdkIsb0JBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxFQUFFLENBQUE7QUFDM0Isb0JBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFBO2FBQzNCO1NBQ0o7OztlQUVVLHVCQUFHO0FBQ1YsZUFBRyxDQUFDLEtBQUssQ0FBQyx3Q0FBd0MsQ0FBQyxDQUFBO0FBQ25ELGdCQUFJLFdBQVcsR0FBRyxDQUFDLFFBQVEsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxrQkFBa0IsQ0FBQyxDQUFBO0FBQ3BFLGdCQUFJLGNBQWMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFBO0FBQzlELGdCQUFJLENBQUMsMEJBQTBCLEdBQUcsMEJBQU0sY0FBYyxFQUFFLFdBQVcsQ0FBQyxDQUFBO0FBQ3BFLGdCQUFJLENBQUMsMEJBQTBCLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQTtBQUMxRCxnQkFBSSxDQUFDLDBCQUEwQixDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUE7O0FBRTFELGdCQUFJLENBQUMsMEJBQTBCLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFBLFVBQVUsR0FBRyxFQUFFO0FBQ3ZELG1CQUFHLENBQUMsS0FBSyxDQUFDLHlCQUF5QixHQUFHLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUNuRCxvQkFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUU7QUFDbEIsd0JBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDO0FBQ3ZCLHNCQUFFLENBQUMsR0FBRyxDQUFDLENBQUM7aUJBQ1g7YUFDSixDQUFBLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDZCxnQkFBSSxDQUFDLDBCQUEwQixDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsQ0FBQSxVQUFVLElBQUksRUFBRSxNQUFNLEVBQUU7QUFDL0QsbUJBQUcsQ0FBQyxLQUFLLENBQUMsNkNBQTZDLEdBQUcsSUFBSSxHQUFHLFdBQVcsR0FBRyxNQUFNLENBQUMsQ0FBQztBQUN2RixvQkFBSSxDQUFDLDBCQUEwQixHQUFHLElBQUksQ0FBQzthQUMxQyxDQUFBLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDZCxlQUFHLENBQUMsS0FBSyxDQUFDLDJFQUEyRSxDQUFDLENBQUM7U0FDMUY7OztlQUVhOzs7O0FBQ1YsMkJBQUcsQ0FBQyxLQUFLLENBQUMsOEJBQThCLENBQUMsQ0FBQTs7NEJBQ3BDLElBQUksQ0FBQyxZQUFZOzs7OztBQUNsQiwyQkFBRyxDQUFDLElBQUksQ0FBQywrREFBK0QsQ0FBQyxDQUFDOzs7O0FBRzlFLDRCQUFJLENBQUMsWUFBWSxDQUFDLGtCQUFrQixDQUFDLG9DQUFpQixhQUFhLENBQUMsQ0FBQzs7NkJBQ2pFLElBQUksQ0FBQyxZQUFZOzs7Ozs0QkFDWixJQUFJLENBQUMsa0JBQWtCOzs7Ozs7eURBQ2xCLElBQUksQ0FBQyxXQUFXLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQzs7Ozt5REFHaEQsSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLEVBQUU7OztBQUNsQyw0QkFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7Ozt5REFFbkIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDOzs7QUFDakQsMkJBQUcsQ0FBQyxLQUFLLENBQUMsbUNBQW1DLENBQUMsQ0FBQTs7Ozs7OztTQUNqRDs7O2VBRWUsb0JBQUMsTUFBTTtnQkFBRSxNQUFNLHlEQUFHLEVBQUU7Z0JBQzVCLEtBQUs7Ozs7QUFBTCw2QkFBSyxHQUFHLEVBQUMsTUFBTSxFQUFOLE1BQU0sRUFBRSxNQUFNLEVBQU4sTUFBTSxFQUFDOzt5REFDZixJQUFJLENBQUMsV0FBVyxDQUFDLGFBQWEsQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDOzs7Ozs7Ozs7O1NBQzdEOzs7ZUFFaUIscUJBQUMsSUFBSTtnQkFBRSxLQUFLLHlEQUFHLEVBQUU7Z0JBSzNCLFVBQVU7Ozs7Ozs0QkFKVCxJQUFJLENBQUMsWUFBWTs7Ozs7OEJBQ1osSUFBSSxLQUFLLENBQUMsdUNBQXVDLENBQUM7OztBQUd4RCxrQ0FBVSxHQUFHLFNBQWIsVUFBVTs7Ozs7Ozt5RUFDRyxhQUFhLFVBQUMsT0FBTyxFQUFFLE1BQU0sRUFBSztBQUMzQyxnREFBSSxHQUFHLEdBQUcsZUFBYyxFQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztBQUM1QyxnREFBSSxPQUFPLEdBQU0sSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsUUFBSyxDQUFDO0FBQzFDLCtDQUFHLENBQUMsS0FBSyxxQ0FBbUMsb0JBQUUsS0FBSyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBRyxDQUFDO0FBQzdFLGdEQUFHO0FBQ0MsdURBQUssWUFBWSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUNqQyx1REFBSyxZQUFZLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDOzZDQUN6QyxDQUFDLE9BQU0sR0FBRyxFQUFFO0FBQ1QsdURBQUssWUFBWSxDQUFDLGtCQUFrQixDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQzdDLHVEQUFLLFlBQVksQ0FBQyxrQkFBa0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUNoRCx1REFBSyxZQUFZLEdBQUcsaUJBQUksT0FBTyxDQUFDLE9BQUssVUFBVSxFQUFFLFlBQVc7QUFDeEQsdURBQUcsQ0FBQyxLQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQTs7QUFFaEMsMkRBQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQTtpREFDdEIsQ0FBQyxDQUFDOzZDQUNOO0FBQ0QsZ0RBQUksVUFBVSxHQUFHLEVBQUUsQ0FBQzs7QUFFcEIsbURBQUssWUFBWSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEdBQUcsRUFBRSxFQUFFLFlBQU07QUFDMUMsbURBQUcsQ0FBQyxLQUFLLENBQUMsMkJBQTJCLENBQUMsQ0FBQTtBQUN0Qyx1REFBSyxZQUFZLENBQUMsa0JBQWtCLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDN0MsdURBQUssWUFBWSxDQUFDLGtCQUFrQixDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQ2hELHVEQUFPLENBQUMsRUFBRSxDQUFDLENBQUE7NkNBQ2QsQ0FBQyxDQUFBOztBQUVGLG1EQUFLLFlBQVksQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLFVBQUMsSUFBSSxFQUFLO0FBQ25DLG1EQUFHLENBQUMsS0FBSyxDQUFDLDBDQUEwQyxDQUFDLENBQUM7QUFDdEQsb0RBQUk7QUFDQSw4REFBVSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxDQUFDO0FBQzNDLHVEQUFHLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFBOzs7QUFHckIsMkRBQUssWUFBWSxDQUFDLGtCQUFrQixDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQzdDLDJEQUFLLFlBQVksQ0FBQyxrQkFBa0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUNoRCx3REFBSSxVQUFVLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtBQUN6QiwrREFBTyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztxREFDN0I7QUFDRCwwREFBTSxDQUFDLHFDQUFjLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO2lEQUM1QyxDQUFDLE9BQU8sR0FBRyxFQUFFO0FBQ1YsdURBQUcsQ0FBQyxLQUFLLENBQUMsb0NBQW9DLENBQUMsQ0FBQztBQUNoRCw4REFBVSxJQUFJLElBQUksQ0FBQztpREFDdEI7NkNBQ0osQ0FBQyxDQUFDO3lDQUNOLENBQUM7Ozs7Ozs7Ozs7eUJBR0w7Ozt5REFDWSxVQUFVLEVBQUU7Ozs7Ozs7Ozs7U0FDNUI7OztlQUVrQjs7Ozs7OzREQUNSLDBCQUFNLFVBQUMsT0FBTyxFQUFFLE1BQU0sRUFBSztBQUM5QixtQ0FBSyxZQUFZLEdBQUcsaUJBQUksT0FBTyxDQUFDLE9BQUssU0FBUyxFQUFFLFlBQVk7QUFDeEQsbUNBQUcsQ0FBQyxLQUFLLENBQUMsa0NBQWtDLENBQUMsQ0FBQTtBQUM3Qyx1Q0FBTyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQTs2QkFDN0IsQ0FBQyxDQUFBO3lCQUNMLENBQUM7Ozs7Ozs7U0FDTDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7V0FoUUMsVUFBVTs7O3FCQWdZRCxVQUFVIiwiZmlsZSI6ImxpYi90ZXN0YnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtzcGF3bn0gZnJvbSAnY2hpbGRfcHJvY2VzcydcclxuXHJcblxyXG5pbXBvcnQge1VpQXV0b21hdG9yX1Rlc3R9IGZyb20gJ2FwcGl1bS11aWF1dG9tYXRvcidcclxuXHJcbmltcG9ydCBuZXQgZnJvbSAnbmV0JztcclxuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IEIgZnJvbSAnYmx1ZWJpcmQnO1xyXG5pbXBvcnQge2Vycm9yRnJvbUNvZGV9IGZyb20gJ2FwcGl1bS1iYXNlLWRyaXZlcic7XHJcbmltcG9ydCB7IHNsZWVwLCByZXRyeSwgcmV0cnlJbnRlcnZhbCB9IGZyb20gJ2FzeW5jYm94JztcclxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnYXBwaXVtLXN1cHBvcnQnO1xyXG5cclxuXHJcbmNvbnN0IGxvZyA9IGxvZ2dlci5nZXRMb2dnZXIoJ0FuZHJvaWRUZXN0QnVuZGxlJyk7XHJcblxyXG5jb25zdCBDT01NQU5EX1RZUEVTID0ge1xyXG4gICAgQUNUSU9OOiAnYWN0aW9uJyxcclxuICAgIFNIVVRET1dOOiAnc2h1dGRvd24nXHJcbn07XHJcblxyXG5jbGFzcyBUZXN0QnVuZGxlIHtcclxuICAgIGNvbnN0cnVjdG9yKGFkYiwgcG9ydCkge1xyXG4gICAgICAgIHRoaXMuYWRiID0gYWRiXHJcbiAgICAgICAgdGhpcy53ZWJTb2NrZXQgPSBwb3J0IC8vb3B0cy53ZWJTb2NrZXRcclxuICAgICAgICB0aGlzLnN5c3RlbVBvcnQgPSBwb3J0IC8vb3B0cy5zeXN0ZW1Qb3J0XHJcbiAgICAgICAgbG9nLmRlYnVnKCdjcmVhdGVkIHRlc3RidW5kbGUnKVxyXG4gICAgICAgIHRoaXMubG9nY2F0X3Byb2NfZm9yX3Rlc3RidW5kbGUgPSBudWxsXHJcbiAgICAgICAgdGhpcy5vblVuZXhwZWN0ZWRTaHV0ZG93biA9IG5ldyBCKCgpID0+IHt9KS5jYW5jZWxsYWJsZSgpO1xyXG4gICAgICAgIHRoaXMuaWdub3JlVW5leHBlY3RlZFNodXRkb3duID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jdXJDb21tYW5kID0ge31cclxuICAgICAgICB0aGlzLnNodXRkb3duVW5leHBlY3RlZCA9IGZhbHNlXHJcbiAgICB9XHJcbiAgICBhc3luYyBpbml0ICgpIHtcclxuICAgICAgICB0aGlzLnVpQXV0b21hdG9yMiA9IG5ldyBVaUF1dG9tYXRvcl9UZXN0KHRoaXMuYWRiKTtcclxuICAgIH1cclxuICAgIGFzeW5jIHN0YXJ0KCkge1xyXG5cclxuICAgICAgICBhd2FpdCB0aGlzLmluaXQoKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFkYi5yZW1vdmVQb3J0Rm9yd2FyZCh0aGlzLnN5c3RlbVBvcnQpXHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgLy8gbG9nLmRlYnVnKGVycilcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGF3YWl0IHRoaXMuYWRiLmZvcndhcmRQb3J0KHRoaXMuc3lzdGVtUG9ydCwgNDcyNCk7XHJcblxyXG4gICAgICAgIHRoaXMucHJvY2VzcyA9IGF3YWl0IHRoaXMudWlBdXRvbWF0b3IyLnN0YXJ0KCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5wcm9jZXNzLm9uKCdvdXRwdXQnLCAoc3Rkb3V0LCBzdGRlcnIpID0+IHtcclxuICAgICAgICAgICAgbGV0IHN0ZG91dExpbmVzID0gKHN0ZG91dCB8fCBcIlwiKS5zcGxpdChcIlxcblwiKTtcclxuICAgICAgICAgICAgY29uc3QgdWlhdXRvTG9nID0gL1xcW0FQUElVTS1VSUFVVE9cXF0oLispXFxbXFwvQVBQSVVNLVVJQVVUT1xcXS87XHJcbiAgICAgICAgICAgIGZvciAobGV0IGxpbmUgb2Ygc3Rkb3V0TGluZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsaW5lLnRyaW0oKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh1aWF1dG9Mb2cudGVzdChsaW5lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cuaW5mbyhgW1RFU1RCVU5ETEUgTE9HXSAke3VpYXV0b0xvZy5leGVjKGxpbmUpWzFdLnRyaW0oKX1gKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoYFtURVNUQlVORExFIFNURE9VVF0gJHtsaW5lfWApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgc3RkZXJyTGluZXMgPSAoc3RkZXJyIHx8IFwiXCIpLnNwbGl0KFwiXFxuXCIpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHN0ZGVyckxpbmVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGluZS50cmltKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoYFtURVNUQlVORExFIFNUREVSUl0gJHtsaW5lfWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy51aUF1dG9tYXRvcjIub24oVWlBdXRvbWF0b3JfVGVzdC5FVkVOVF9DSEFOR0VELCBhc3luYyAobXNnKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChtc2cuc3RhdGUgPT09IFVpQXV0b21hdG9yX1Rlc3QuU1RBVEVfU1RPUFBFRCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51aUF1dG9tYXRvciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBsb2cuZGVidWcoXCJUZXN0QnVuZGxlIHNodXRkb3duIHVuZXhwZWN0ZWRseVwiKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zaHV0ZG93blVuZXhwZWN0ZWQgPSB0cnVlXHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uVW5leHBlY3RlZFNodXRkb3duLmNhbmNlbChuZXcgRXJyb3IoXCJUZXN0QnVuZGxlIHNodXQgZG93biB1bmV4cGVjdGVkbHlcIikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlICgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNvY2tldENsaWVudCA9IG5ldC5jb25uZWN0KHRoaXMuc3lzdGVtUG9ydCk7XHJcbiAgICAgICAgICAgICAgICAvLyBXaW5kb3dzOiB0aGUgc29ja2V0IGVycm9ycyBvdXQgd2hlbiBBREIgcmVzdGFydHMuIExldCdzIGNhdGNoIGl0IHRvIGF2b2lkIGNyYXNoaW5nLlxyXG4vKiAgICAgICAgICAgICAgICB0aGlzLnNvY2tldENsaWVudC5vbignZXJyb3InLCAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nLmRlYnVnKCcvLy8vLy8vLy8vLy8vLycpXHJcbiAgICAgICAgICAgICAgICAgICAgbG9nLmRlYnVnKGVycilcclxuICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoJy8vLy8vLy8vLy8vLy8vJylcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5pZ25vcmVVbmV4cGVjdGVkU2h1dGRvd24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy90aHJvdyBuZXcgRXJyb3IoYEFuZHJvaWQgdGVzdGJ1bmRsZSBzb2NrZXQgY3Jhc2hlZDogJHtlcnJ9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7Ki9cclxuICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0Q2xpZW50Lm9uY2UoJ2Nvbm5lY3QnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nLmluZm8oXCJBbmRyb2lkIHRlc3RidW5kbGUgc29ja2V0IGlzIG5vdyBjb25uZWN0ZWRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgIC8vIGtpbGwgVGVzdEJ1bmRsZVxyXG4gICAgICAgIC8qICAgICAgICBhd2FpdCB0aGlzLmFkYi5raWxsUHJvY2Vzc2VzQnlOYW1lKCd0ZXN0YnVuZGxlJylcclxuICAgICAgICAgbGV0IGFyZ3MgPSBbJ3NoZWxsJywgJ2FtJywgJ2luc3RydW1lbnQnLCAnLXcnLCAnLWUnLCAnY2xhc3MnLCAnY29tLmJveWFhLmFwcGxpY2F0aW9uLnRlc3RidW5kbGUuVGVzdEJ1bmRsZSN0ZXN0X1J1blNlcnZlcicsXHJcbiAgICAgICAgICdjb20uYm95YWEuYXBwbGljYXRpb24udGVzdGJ1bmRsZS9hbmRyb2lkLnRlc3QuSW5zdHJ1bWVudGF0aW9uVGVzdFJ1bm5lciddXHJcblxyXG4gICAgICAgICBsb2cuZGVidWcoXCJzcGF3bmluZzogXCIgKyBhcmdzLmpvaW4oJyAnKSlcclxuICAgICAgICAgdGhpcy5wcm9jID0gdGhpcy5hZGIuY3JlYXRlU3ViUHJvY2VzcyhhcmdzKVxyXG5cclxuICAgICAgICAgdGhpcy5wcm9jLm9uKCdleGl0JywgKGNvZGUsIHNpZ25hbCkgPT4ge1xyXG4gICAgICAgICBsZXQgbXNnID0gYFRlc3RidW5kbGUgc2h1dGRvd24gd2l0aCBjb2RlICR7Y29kZX0sIGAgKyBgc2lnbmFsICR7c2lnbmFsfWA7XHJcbiAgICAgICAgIGxvZy5kZWJ1Zyhtc2cpO1xyXG4gICAgICAgICB0aGlzLmV4aXRIYW5kbGVyLmJpbmQodGhpcylcclxuICAgICAgICAgfSlcclxuICAgICAgICAgLyEqICAgICAgICB0aGlzLnByb2Mub24oXCJlcnJvclwiLCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgIGxvZy5lcnJvcihcIlVuYWJsZSB0byBzcGF3biBhZGI6IFwiICsgZXJyLm1lc3NhZ2UpO1xyXG4gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gc3RhcnQgQW5kcm9pZCBEZWJ1ZyBCcmlkZ2U6IFwiICsgZXJyLm1lc3NhZ2UpXHJcbiAgICAgICAgIH0uYmluZCh0aGlzKSkqIS9cclxuXHJcbiAgICAgICAgIGF3YWl0IHRoaXMucHJvYy5zdGFydCgpXHJcblxyXG4gICAgICAgICB0aGlzLnByb2Mub24oJ291dHB1dCcsIChzdGRvdXQsIHN0ZGVycikgPT4ge1xyXG4gICAgICAgICBsb2cuZGVidWcoc3Rkb3V0KVxyXG4gICAgICAgICBsb2cuZGVidWcoc3RkZXJyKVxyXG4gICAgICAgICB9KSovXHJcblxyXG4gICAgICAgIC8qICAgICAgICBsb2cuZGVidWcoJ3NwYXduaW5nIHh4eHh4eHh4eHh4eHgnKVxyXG4gICAgICAgICBsb2cuZGVidWcodGhpcy5hZGIuZ2V0QWRiUGF0aCgpICsgdGhpcy5hZGIuZXhlY3V0YWJsZS5kZWZhdWx0QXJncy5jb25jYXQoYXJncykpXHJcbiAgICAgICAgIHRoaXMucHJvYyA9IHNwYXduKHRoaXMuYWRiLmdldEFkYlBhdGgoKSwgdGhpcy5hZGIuZXhlY3V0YWJsZS5kZWZhdWx0QXJncy5jb25jYXQoYXJncykpXHJcblxyXG4gICAgICAgICB0aGlzLnByb2Muc3Rkb3V0Lm9uKCdkYXRhJywgKGRhdGEpID0+IHtcclxuICAgICAgICAgbG9nLmRlYnVnKGBzdGRvdXQ6ICR7ZGF0YX1gKTtcclxuICAgICAgICAgfSk7XHJcbiAgICAgICAgIHRoaXMucHJvYy5zdGRlcnIub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xyXG4gICAgICAgICBsb2cuZGVidWcoYHN0ZGVycjogJHtkYXRhfWApO1xyXG4gICAgICAgICB9KTsqL1xyXG5cclxuICAgICAgICAvKiAgICAgICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgdGhpcy5zb2NrZXRDbGllbnQgPSBuZXQuY29ubmVjdCh0aGlzLndlYlNvY2tldCk7XHJcbiAgICAgICAgIC8vIFdpbmRvd3M6IHRoZSBzb2NrZXQgZXJyb3JzIG91dCB3aGVuIEFEQiByZXN0YXJ0cy4gTGV0J3MgY2F0Y2ggaXQgdG8gYXZvaWQgY3Jhc2hpbmcuXHJcbiAgICAgICAgIHRoaXMuc29ja2V0Q2xpZW50Lm9uKCdlcnJvcicsIChlcnIpID0+IHtcclxuICAgICAgICAgaWYgKCF0aGlzLmlnbm9yZVVuZXhwZWN0ZWRTaHV0ZG93bikge1xyXG4gICAgICAgICAvL3Rocm93IG5ldyBFcnJvcihgQW5kcm9pZCBib290c3RyYXAgc29ja2V0IGNyYXNoZWQ6ICR7ZXJyfWApO1xyXG4gICAgICAgICBsb2cuZGVidWcoJy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8nKVxyXG4gICAgICAgICBsb2cuZGVidWcoZXJyKVxyXG4gICAgICAgICBsb2cuZGVidWcoJy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8nKVxyXG4gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFuZHJvaWQgdGVzdGJ1bmRsZSBzb2NrZXQgY3Jhc2hlZDogJHtlcnJ9YClcclxuICAgICAgICAgfVxyXG4gICAgICAgICB9KTtcclxuICAgICAgICAgdGhpcy5zb2NrZXRDbGllbnQub25jZSgnY29ubmVjdCcsICgpID0+IHtcclxuICAgICAgICAgbG9nLmluZm8oXCJBbmRyb2lkIHRlc3RidW5kbGUgc29ja2V0IGlzIG5vdyBjb25uZWN0ZWRcIik7XHJcbiAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgfSk7XHJcbiAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgfVxyXG4gICAgICAgICB9KSovXHJcbiAgICB9XHJcblxyXG4gICAgZXhpdEhhbmRsZXIoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0Q2xpZW50KSB7XHJcbiAgICAgICAgICAgIGxvZy5kZWJ1ZygnZW5kaW5nIHRlc3RidW5kbGUgc29ja2V0Q2xpZW50JylcclxuICAgICAgICAgICAgdGhpcy5zb2NrZXRDbGllbnQuZW5kKClcclxuICAgICAgICAgICAgdGhpcy5zb2NrZXRDbGllbnQuZGVzdHJveSgpXHJcbiAgICAgICAgICAgIHRoaXMuc29ja2V0Q2xpZW50ID0gbnVsbFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzdGFydExvZ2NhdCgpIHtcclxuICAgICAgICBsb2cuZGVidWcoXCJTdGFydGluZyBsb2djYXQgY2FwdHVyZSBmb3IgdGVzdGJ1bmRsZVwiKVxyXG4gICAgICAgIGxldCBsb2djYXRfYXJncyA9IFtcImxvZ2NhdFwiLCBcIi12XCIsIFwidGltZVwiLCBcIi1zXCIsIFwiQk9ZQUEtVEVTVEJVTkRMRVwiXVxyXG4gICAgICAgIGxldCBleGVjdXRhYmxlUGF0aCA9IHRoaXMuYWRiLmV4ZWN1dGFibGUuZGVmYXVsdEFyZ3Muam9pbignICcpXHJcbiAgICAgICAgdGhpcy5sb2djYXRfcHJvY19mb3JfdGVzdGJ1bmRsZSA9IHNwYXduKGV4ZWN1dGFibGVQYXRoLCBsb2djYXRfYXJncylcclxuICAgICAgICB0aGlzLmxvZ2NhdF9wcm9jX2Zvcl90ZXN0YnVuZGxlLnN0ZG91dC5zZXRFbmNvZGluZygndXRmOCcpXHJcbiAgICAgICAgdGhpcy5sb2djYXRfcHJvY19mb3JfdGVzdGJ1bmRsZS5zdGRlcnIuc2V0RW5jb2RpbmcoJ3V0ZjgnKVxyXG5cclxuICAgICAgICB0aGlzLmxvZ2NhdF9wcm9jX2Zvcl90ZXN0YnVuZGxlLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgbG9nLmVycm9yKCdMb2djYXQgY2FwdHVyZSBmYWlsZWQ6ICcgKyBlcnIubWVzc2FnZSk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5jYWxsZWRCYWNrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxlZEJhY2sgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgY2IoZXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5sb2djYXRfcHJvY19mb3JfdGVzdGJ1bmRsZS5vbignZXhpdCcsIGZ1bmN0aW9uIChjb2RlLCBzaWduYWwpIHtcclxuICAgICAgICAgICAgbG9nLmRlYnVnKCdMb2djYXQgZm9yIHRlc3RidW5kbGUgdGVybWluYXRlZCB3aXRoIGNvZGUgJyArIGNvZGUgKyAnLCBzaWduYWwgJyArIHNpZ25hbCk7XHJcbiAgICAgICAgICAgIHRoaXMubG9nY2F0X3Byb2NfZm9yX3Rlc3RidW5kbGUgPSBudWxsO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgbG9nLmRlYnVnKFwiUmVkaXJlY3RpbmcgbG9nY2F0IGxvZ3MgaW50byBjb25zb2xlIHRvIG1ha2UgaXQgcmVjZWl2ZWQgYnkgYXBwaXVtIHNlcnZlclwiKTtcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBzaHV0ZG93bigpIHtcclxuICAgICAgICBsb2cuZGVidWcoJ3NodXR0aW5nIGRvd24gdGVzdGJ1bmRsZSAuLi4nKVxyXG4gICAgICAgIGlmICghdGhpcy51aUF1dG9tYXRvcjIpIHtcclxuICAgICAgICAgICAgbG9nLndhcm4oXCJDYW5ub3Qgc2h1dCBkb3duIEFuZHJvaWQgdGVzdGJ1bmRsZTsgaXQgaGFzIGFscmVhZHkgc2h1dCBkb3duXCIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudWlBdXRvbWF0b3IyLnJlbW92ZUFsbExpc3RlbmVycyhVaUF1dG9tYXRvcl9UZXN0LkVWRU5UX0NIQU5HRUQpO1xyXG4gICAgICAgIGlmICh0aGlzLnNvY2tldENsaWVudCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuc2h1dGRvd25VbmV4cGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNlbmRDb21tYW5kKENPTU1BTkRfVFlQRVMuU0hVVERPV04pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGF3YWl0IHRoaXMudWlBdXRvbWF0b3IyLnNodXRkb3duKCk7XHJcbiAgICAgICAgdGhpcy51aUF1dG9tYXRvcjIgPSBudWxsO1xyXG5cclxuICAgICAgICBhd2FpdCB0aGlzLmFkYi5yZW1vdmVQb3J0Rm9yd2FyZCh0aGlzLnN5c3RlbVBvcnQpXHJcbiAgICAgICAgbG9nLmRlYnVnKCdzaHV0dGluZyBkb3duIHRlc3RidW5kbGUgLi4uZG9uZSEnKVxyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIHNlbmRBY3Rpb24oYWN0aW9uLCBwYXJhbXMgPSB7fSkge1xyXG4gICAgICAgIGxldCBleHRyYSA9IHthY3Rpb24sIHBhcmFtc307XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VuZENvbW1hbmQoQ09NTUFORF9UWVBFUy5BQ1RJT04sIGV4dHJhKTtcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBzZW5kQ29tbWFuZCAodHlwZSwgZXh0cmEgPSB7fSkge1xyXG4gICAgICAgIGlmICghdGhpcy5zb2NrZXRDbGllbnQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTb2NrZXQgY29ubmVjdGlvbiBjbG9zZWQgdW5leHBlY3RlZGx5Jyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgZXhlY29tbWFuZCA9IGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlICgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY21kID0gT2JqZWN0LmFzc2lnbih7Y21kOiB0eXBlfSwgZXh0cmEpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNtZEpzb24gPSBgJHtKU09OLnN0cmluZ2lmeShjbWQpfSBcXG5gO1xyXG4gICAgICAgICAgICAgICAgbG9nLmRlYnVnKGBTZW5kaW5nIGNvbW1hbmQgdG8gdGVzdGJ1bmRsZTogJHtfLnRydW5jKGNtZEpzb24sIDEwMDApLnRyaW0oKX1gKTtcclxuICAgICAgICAgICAgICAgIHRyeXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldENsaWVudC53cml0ZShjbWRKc29uKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldENsaWVudC5zZXRFbmNvZGluZygndXRmOCcpO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldENsaWVudC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2RhdGEnKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldENsaWVudC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3RpbWVvdXQnKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldENsaWVudCA9IG5ldC5jb25uZWN0KHRoaXMuc3lzdGVtUG9ydCwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5kZWJ1Zygnc29ja2V0IHJlY29ubmVjdGVkIScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIGV4ZWNvbW1hbmQoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGV4ZWNvbW1hbmQpXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgc3RyZWFtRGF0YSA9ICcnO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0Q2xpZW50LnNldFRpbWVvdXQoMTAwMCAqIDYwLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nLmRlYnVnKCd0ZXN0YnVuZGxlIHNvY2tldCB0aW1lb3V0JylcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldENsaWVudC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2RhdGEnKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldENsaWVudC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3RpbWVvdXQnKTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCcnKVxyXG4gICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNvY2tldENsaWVudC5vbignZGF0YScsIChkYXRhKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nLmRlYnVnKFwiUmVjZWl2ZWQgY29tbWFuZCByZXN1bHQgZnJvbSB0ZXN0YnVuZGxlOlwiKTtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1EYXRhID0gSlNPTi5wYXJzZShzdHJlYW1EYXRhICsgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZyhzdHJlYW1EYXRhKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBzdWNjZXNzZnVsbHkgcGFyc2VkIEpTT04gc28gd2UndmUgZ290IGFsbCB0aGUgZGF0YSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBzb2NrZXQgbGlzdGVuZXIgYW5kIGV2YWx1YXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0Q2xpZW50LnJlbW92ZUFsbExpc3RlbmVycygnZGF0YScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldENsaWVudC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3RpbWVvdXQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmVhbURhdGEuc3RhdHVzID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHN0cmVhbURhdGEudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvckZyb21Db2RlKHN0cmVhbURhdGEuc3RhdHVzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoaWduKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZyhcIlN0cmVhbSBzdGlsbCBub3QgY29tcGxldGUsIHdhaXRpbmdcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbURhdGEgKz0gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IGV4ZWNvbW1hbmQoKVxyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGdldENvbm5lY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5zb2NrZXRDbGllbnQgPSBuZXQuY29ubmVjdCh0aGlzLndlYlNvY2tldCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgbG9nLmRlYnVnKCd0ZXN0YnVuZGxlIHNvY2tldCByZWNvbm5lY3RlZCEhIScpXHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMuc29ja2V0Q2xpZW50KVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLyphc3luYyBzZW5kQ29tbWFuZCh0eXBlLCBleHRyYSA9IHt9KSB7XHJcbiAgICAgLyEqICAgICAgICBpZiAoIXRoaXMuc29ja2V0Q2xpZW50KSB7XHJcbiAgICAgbG9nLmRlYnVnKCc9PT09PT09PT09c29ja2V0IGNsb3NlZD09PT09PT09JylcclxuICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NvY2tldCBjb25uZWN0aW9uIGNsb3NlZCB1bmV4cGVjdGVkbHknKTtcclxuICAgICB9KiEvXHJcbiAgICAgcmV0dXJuIGF3YWl0IG5ldyBCKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICBsZXQgY21kID0gT2JqZWN0LmFzc2lnbih7Y21kOiB0eXBlfSwgZXh0cmEpO1xyXG4gICAgIGxldCBjbWRKc29uID0gYCR7SlNPTi5zdHJpbmdpZnkoY21kKX1cXG5gO1xyXG4gICAgIGxvZy5kZWJ1ZyhgU2VuZGluZyBjb21tYW5kIHRvIGFuZHJvaWQgdGVzdGJ1bmRsZTogJHtfLnRydW5jKGNtZEpzb24sIDEwMDApLnRyaW0oKX1gKTtcclxuXHJcbiAgICAgbGV0IGV4ZUZ1bmMgPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgdHJ5IHtcclxuXHJcbiAgICAgaWYgKHRoaXMuc29ja2V0Q2xpZW50KSB7XHJcbiAgICAgdGhpcy5zb2NrZXRDbGllbnQud3JpdGUoY21kSnNvbik7XHJcbiAgICAgdGhpcy5zb2NrZXRDbGllbnQuc2V0RW5jb2RpbmcoJ3V0ZjgnKTtcclxuICAgICB0aGlzLnNvY2tldENsaWVudCgnZGF0YScsIChkYXRhKSA9PiB7XHJcbiAgICAgdHJ5IHtcclxuICAgICBzdHJlYW1EYXRhID0gSlNPTi5wYXJzZShzdHJlYW1EYXRhICsgZGF0YSk7XHJcbiAgICAgLy8gd2Ugc3VjY2Vzc2Z1bGx5IHBhcnNlZCBKU09OIHNvIHdlJ3ZlIGdvdCBhbGwgdGhlIGRhdGEsXHJcbiAgICAgLy8gcmVtb3ZlIHRoZSBzb2NrZXQgbGlzdGVuZXIgYW5kIGV2YWx1YXRlXHJcbiAgICAgdGhpcy5zb2NrZXRDbGllbnQucmVtb3ZlQWxsTGlzdGVuZXJzKCdkYXRhJyk7XHJcbiAgICAgaWYgKHN0cmVhbURhdGEuc3RhdHVzID09PSAwKSB7XHJcbiAgICAgcmVzb2x2ZShzdHJlYW1EYXRhLnZhbHVlKTtcclxuICAgICB9XHJcbiAgICAgbG9nLmRlYnVnKFwiUmVjZWl2ZWQgY29tbWFuZCByZXN1bHQgZnJvbSB0ZXN0YnVuZGxlOlwiICsgSlNPTi5zdHJpbmdpZnkoc3RyZWFtRGF0YSkpO1xyXG4gICAgIHJlamVjdChlcnJvckZyb21Db2RlKHN0cmVhbURhdGEuc3RhdHVzKSk7XHJcbiAgICAgfSBjYXRjaCAoaWduKSB7XHJcbiAgICAgbG9nLmRlYnVnKFwiU3RyZWFtIHN0aWxsIG5vdCBjb21wbGV0ZSwgd2FpdGluZ1wiKTtcclxuICAgICBzdHJlYW1EYXRhICs9IGRhdGE7XHJcbiAgICAgfVxyXG4gICAgIH0pXHJcbiAgICAgfVxyXG5cclxuICAgICBlbHNlIHtcclxuICAgICBsZXQgY2xpZW50ID0gbmV3IG5ldC5Tb2NrZXQoKTtcclxuICAgICBsZXQgc3RyZWFtRGF0YSA9ICcnO1xyXG4gICAgIGNsaWVudC5jb25uZWN0KHRoaXMud2ViU29ja2V0LCAnMTI3LjAuMC4xJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgbG9nLmRlYnVnKCd0ZXN0YnVuZGxlIHNvY2tldCByZWNvbm5lY3RlZCEnKVxyXG4gICAgIGxvZy5kZWJ1Zygnc2VuZCBzdHJlYW0nKVxyXG4gICAgIGNsaWVudC53cml0ZShjbWRKc29uKTtcclxuICAgICBsb2cuZGVidWcoJ3NlbmQgZW5kJylcclxuICAgICBjbGllbnQuc2V0RW5jb2RpbmcoJ3V0ZjgnKTtcclxuXHJcblxyXG5cclxuICAgICB9KVxyXG4gICAgIGNsaWVudC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2RhdGEnKTtcclxuICAgICBjbGllbnQub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xyXG4gICAgIHRyeSB7XHJcbiAgICAgbG9nLmRlYnVnKFwiZGF0YTpcIiArIGRhdGEudG9TdHJpbmcoKSlcclxuICAgICBzdHJlYW1EYXRhID0gSlNPTi5wYXJzZShzdHJlYW1EYXRhICsgZGF0YSk7XHJcblxyXG4gICAgIGxvZy5kZWJ1ZyhcInN0cmVhbWRhdGE6IFwiICsgc3RyZWFtRGF0YSlcclxuXHJcbiAgICAgLy8gd2Ugc3VjY2Vzc2Z1bGx5IHBhcnNlZCBKU09OIHNvIHdlJ3ZlIGdvdCBhbGwgdGhlIGRhdGEsXHJcbiAgICAgLy8gcmVtb3ZlIHRoZSBzb2NrZXQgbGlzdGVuZXIgYW5kIGV2YWx1YXRlXHJcbiAgICAgbG9nLmRlYnVnKFwiUmVjZWl2ZWQgY29tbWFuZCByZXN1bHQgZnJvbSB0ZXN0YnVuZGxlOlwiICsgSlNPTi5zdHJpbmdpZnkoc3RyZWFtRGF0YSkpO1xyXG4gICAgIGlmIChzdHJlYW1EYXRhLnN0YXR1cyA9PT0gMCkge1xyXG4gICAgIHJlc29sdmUoc3RyZWFtRGF0YS52YWx1ZSk7XHJcbiAgICAgY2xpZW50LnJlbW92ZUFsbExpc3RlbmVycygnZGF0YScpO1xyXG4gICAgIGNsaWVudC5jbG9zZSgpXHJcblxyXG4gICAgIH1cclxuXHJcbiAgICAgcmVqZWN0KGVycm9yRnJvbUNvZGUoc3RyZWFtRGF0YS5zdGF0dXMpKTtcclxuICAgICB9IGNhdGNoIChpZ24pIHtcclxuICAgICBsb2cuZGVidWcoXCJTdHJlYW0gc3RpbGwgbm90IGNvbXBsZXRlLCB3YWl0aW5nXCIpO1xyXG4gICAgIHN0cmVhbURhdGEgKz0gZGF0YTtcclxuICAgICB9XHJcbiAgICAgfSlcclxuICAgICB9XHJcblxyXG5cclxuICAgICAvISogICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0Q2xpZW50LndyaXRlKGNtZEpzb24pO1xyXG4gICAgIHRoaXMuc29ja2V0Q2xpZW50LnNldEVuY29kaW5nKCd1dGY4Jyk7XHJcbiAgICAgbGV0IHN0cmVhbURhdGEgPSAnJztcclxuICAgICB0aGlzLnNvY2tldENsaWVudC5vbignZGF0YScsIChkYXRhKSA9PiB7XHJcbiAgICAgdHJ5IHtcclxuICAgICBzdHJlYW1EYXRhID0gSlNPTi5wYXJzZShzdHJlYW1EYXRhICsgZGF0YSk7XHJcbiAgICAgLy8gd2Ugc3VjY2Vzc2Z1bGx5IHBhcnNlZCBKU09OIHNvIHdlJ3ZlIGdvdCBhbGwgdGhlIGRhdGEsXHJcbiAgICAgLy8gcmVtb3ZlIHRoZSBzb2NrZXQgbGlzdGVuZXIgYW5kIGV2YWx1YXRlXHJcbiAgICAgdGhpcy5zb2NrZXRDbGllbnQucmVtb3ZlQWxsTGlzdGVuZXJzKCdkYXRhJyk7XHJcbiAgICAgaWYgKHN0cmVhbURhdGEuc3RhdHVzID09PSAwKSB7XHJcbiAgICAgcmVzb2x2ZShzdHJlYW1EYXRhLnZhbHVlKTtcclxuICAgICB9XHJcbiAgICAgbG9nLmRlYnVnKFwiUmVjZWl2ZWQgY29tbWFuZCByZXN1bHQgZnJvbSB0ZXN0YnVuZGxlOlwiICsgSlNPTi5zdHJpbmdpZnkoc3RyZWFtRGF0YSkpO1xyXG4gICAgIHJlamVjdChlcnJvckZyb21Db2RlKHN0cmVhbURhdGEuc3RhdHVzKSk7XHJcbiAgICAgfSBjYXRjaCAoaWduKSB7XHJcbiAgICAgbG9nLmRlYnVnKFwiU3RyZWFtIHN0aWxsIG5vdCBjb21wbGV0ZSwgd2FpdGluZ1wiKTtcclxuICAgICBzdHJlYW1EYXRhICs9IGRhdGE7XHJcbiAgICAgfVxyXG4gICAgIH0pKiEvXHJcblxyXG4gICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHNlbmRpbmcgY29tbWFuZCB0byB0ZXN0YnVuZGxlJyArIGUpXHJcbiAgICAgfVxyXG4gICAgIH1cclxuICAgICAvL3JldHJ5KDIsIGV4ZUZ1bmMpO1xyXG4gICAgIGV4ZUZ1bmMoKVxyXG5cclxuICAgICAvISp0aGlzLnNvY2tldENsaWVudC53cml0ZShjbWRKc29uKTtcclxuICAgICB0aGlzLnNvY2tldENsaWVudC5zZXRFbmNvZGluZygndXRmOCcpO1xyXG4gICAgIGxldCBzdHJlYW1EYXRhID0gJyc7XHJcbiAgICAgdGhpcy5zb2NrZXRDbGllbnQub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xyXG4gICAgIHRyeSB7XHJcbiAgICAgc3RyZWFtRGF0YSA9IEpTT04ucGFyc2Uoc3RyZWFtRGF0YSArIGRhdGEpO1xyXG4gICAgIC8vIHdlIHN1Y2Nlc3NmdWxseSBwYXJzZWQgSlNPTiBzbyB3ZSd2ZSBnb3QgYWxsIHRoZSBkYXRhLFxyXG4gICAgIC8vIHJlbW92ZSB0aGUgc29ja2V0IGxpc3RlbmVyIGFuZCBldmFsdWF0ZVxyXG4gICAgIHRoaXMuc29ja2V0Q2xpZW50LnJlbW92ZUFsbExpc3RlbmVycygnZGF0YScpO1xyXG4gICAgIGlmIChzdHJlYW1EYXRhLnN0YXR1cyA9PT0gMCkge1xyXG4gICAgIHJlc29sdmUoc3RyZWFtRGF0YS52YWx1ZSk7XHJcbiAgICAgfVxyXG4gICAgIGxvZy5kZWJ1ZyhcIlJlY2VpdmVkIGNvbW1hbmQgcmVzdWx0IGZyb20gdGVzdGJ1bmRsZTpcIiArIEpTT04uc3RyaW5naWZ5KHN0cmVhbURhdGEpKTtcclxuICAgICByZWplY3QoZXJyb3JGcm9tQ29kZShzdHJlYW1EYXRhLnN0YXR1cykpO1xyXG4gICAgIH0gY2F0Y2ggKGlnbikge1xyXG4gICAgIGxvZy5kZWJ1ZyhcIlN0cmVhbSBzdGlsbCBub3QgY29tcGxldGUsIHdhaXRpbmdcIik7XHJcbiAgICAgc3RyZWFtRGF0YSArPSBkYXRhO1xyXG4gICAgIH1cclxuICAgICB9KSohL1xyXG5cclxuICAgICB9KVxyXG5cclxuICAgICB9Ki9cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgVGVzdEJ1bmRsZSJdLCJzb3VyY2VSb290IjoiLi5cXC4uIn0=
